<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[SDWebImage初探]]></title>
      <url>http://nickchenhao.github.io./2019/06/12/SDWebImage%E5%88%9D%E7%BA%A7%E7%A0%94%E7%A9%B6/</url>
      <content type="html"><![CDATA[<p>####流程图<br><img src="/Users/nick/Desktop/1.png" alt="avatar"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[发布过程的问题]]></title>
      <url>http://nickchenhao.github.io./2017/01/23/%E5%8F%91%E5%B8%83%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h3 id="发布时遇到的一些问题"><a href="#发布时遇到的一些问题" class="headerlink" title="发布时遇到的一些问题"></a>发布时遇到的一些问题</h3><h4 id="iOS10-之后需要添加info-plist文件配置"><a href="#iOS10-之后需要添加info-plist文件配置" class="headerlink" title="iOS10 之后需要添加info.plist文件配置:"></a>iOS10 之后需要添加info.plist文件配置:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">     &lt;key&gt;NSBluetoothPeripheralUsageDescription&lt;/key&gt; </span><br><span class="line">     &lt;string&gt;亲啊，打开蓝牙可以吗？&lt;/string&gt; </span><br><span class="line">     &lt;key&gt;NSCameraUsageDescription&lt;/key&gt; </span><br><span class="line">     &lt;string&gt;亲啊，打开相机可以吗？&lt;/string&gt; </span><br><span class="line">     &lt;key&gt;NSContactsUsageDescription&lt;/key&gt; </span><br><span class="line">     &lt;string&gt;亲啊，打开通讯录可以吗？&lt;/string&gt; </span><br><span class="line">     &lt;key&gt;NSMicrophoneUsageDescription&lt;/key&gt; </span><br><span class="line">     &lt;string&gt;亲啊，打开麦克风可以吗？&lt;/string&gt; </span><br><span class="line">     &lt;key&gt;NSPhotoLibraryUsageDescription&lt;/key&gt; </span><br><span class="line">     &lt;string&gt;亲啊，打开相册可以吗？&lt;/string&gt;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>若没有apple会发此邮箱:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">This app attempts to access privacy-sensitive data without a usage description. The app&apos;s Info.plist must contain an NSPhotoLibraryUsageDescription key with a string value explaining to the user how the app uses this data.</span><br><span class="line"></span><br><span class="line">This app attempts to access privacy-sensitive data without a usage description. The app&apos;s Info.plist must contain an NSCameraUsageDescription key with a string value explaining to the user how the app uses this data.</span><br></pre></td></tr></table></figure></p>
<h4 id="报错"><a href="#报错" class="headerlink" title="报错:"></a>报错:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- ERROR ITMS-90474: &quot;Invalid Bundle. iPad Multitasking support requires these orientations: &apos;UIInterfaceOrientationPortrait,UIInterfaceOrientationPortraitUpsideDown,UIInterfaceOrientationLandscapeLeft,UIInterfaceOrientationLandscapeRight&apos;. Found &apos;UIInterfaceOrientationPortrait&apos; in bundle &apos;xxxx&apos;.&quot; </span><br><span class="line">- ERROR ITMS-90475: &quot;Invalid Bundle. iPad Multitasking support requires launch story board in bundle &apos;xxxx’.&quot;</span><br></pre></td></tr></table></figure>
<p>解决方案:<br>打开项目属性，选择“General”选项，勾选红框标注的“Requires full screen”</p>
<h4 id="报错-1"><a href="#报错-1" class="headerlink" title="报错:"></a>报错:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR ITMS-90032:“Invalid Image Path - No image found at the path referenced under key &apos;CFBundleIcons&apos;:AppIcon40x40”</span><br></pre></td></tr></table></figure>
<p>解决方案:<br>图片的问题  缺少对应的图片尺寸 需要在图片资源文件的 appicon中添加</p>
<p><img src="/Users/nick/Desktop/Snip20170122_3.png" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[自定义View 跳转不同界面方法]]></title>
      <url>http://nickchenhao.github.io./2016/07/02/%E8%87%AA%E5%AE%9A%E4%B9%89View%20%E8%B7%B3%E8%BD%AC%E4%B8%8D%E5%90%8C%E7%95%8C%E9%9D%A2%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h2 id="自定义View-跳转不同界面方法"><a href="#自定义View-跳转不同界面方法" class="headerlink" title="自定义View 跳转不同界面方法"></a>自定义View 跳转不同界面方法</h2><p>有时候，我们在自定义UIView 的时候 ， 很有可能 会在这个View 进行页面跳转，但是， 你会发现， 那些 push  和  pop 方法  都没什么用  ，那是因为 当一个子view需要接收点击事件，而父view也需要接收点击事件</p>
<p> 当然，你可能会说直接调用mysubview.superView即可，这样做也确实是可以做到，但有时子view是不一定知道有这个特定的父view的存在的，如动态添加子view。</p>
<p> 所以这里就用到了事件处理与传递。</p>
<a id="more"></a>
<h3 id="简单介绍一下"><a href="#简单介绍一下" class="headerlink" title="简单介绍一下"></a>简单介绍一下</h3><ul>
<li>ios当中常用的事件?</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 触摸事件</span><br><span class="line">- 加速计事件</span><br><span class="line">- 远程控制事件</span><br></pre></td></tr></table></figure>
<ul>
<li>什么是响应者对象?</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">继承了UIResponds的对象我们称它为响应者对象</span><br><span class="line">UIApplication、UIViewController、UIView都继承自UIResponder</span><br><span class="line">因此它们都是响应者对象，都能够接收并处理事件</span><br></pre></td></tr></table></figure>
<ul>
<li>事件是怎么样产生与传递的?</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">当发生一个触摸事件后,系统会将该事件加入到一个由UIApplication管理的事件队列中.</span><br><span class="line">UIApplication会从事件队列中取出最前面的事件，交给主窗口.</span><br><span class="line">主窗口会在视图层次结构中找到一个最合适的视图来处理触摸事件</span><br><span class="line">触摸事件的传递是从父控件传递到子控件的.</span><br><span class="line">如果一个父控件不能接收事件,那么它里面的了子控件也不能够接收事件.</span><br><span class="line">``` </span><br><span class="line">- 一个控件什么情况下不能够接收事件?</span><br></pre></td></tr></table></figure>
<ul>
<li><p>不接收用户交互时不能够处理事件</p>
<pre><code>userInteractionEnabled = NO
</code></pre></li>
<li><p>当一个控件隐藏的时候不能够接收事件</p>
<pre><code>Hidden = YES的时候
</code></pre></li>
<li><p>当一个控件为透明白时候也不能够接收事件</p>
<pre><code>alpha &lt;=0.01
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">##### 注意:UIImageView的userInteractionEnabled默认就是NO，因此UIImageView以及它的子控件默认是不能接收触摸事件的</span><br><span class="line"> </span><br><span class="line">- 如何寻找最合适的View?</span><br></pre></td></tr></table></figure>
</li>
<li><p>先判断自己是否能够接收触摸事件,如果能再继续往下判断,</p>
</li>
<li>再判断触摸的当前点在不在自己的身上.</li>
<li>如果在自己身上,UIWindow会从后往前（后创建的子控件开始）遍历子控件,遍历出每一个子控件后,重复前面的两个步骤.</li>
<li>如果没有符合条件的子控件,那么它自己就是最适合的View.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">回到主题上来，下面要做的也就是，让子view接收这些事件后，同时把这些事件继续向上传，会一直传到UIApplication为止。而在传的过程中，如果子view接收了这些事件，那么事件会自然终止，我们现在可以做的是同时让子view接收事件，而且还让事件不终止，并继续向上传。</span><br><span class="line"></span><br><span class="line">步骤应该是：</span><br><span class="line"></span><br><span class="line">```objc</span><br><span class="line">//定义一个全局变量    </span><br><span class="line">UIViewController *superVC;</span><br><span class="line"></span><br><span class="line">//然后执行这个方法</span><br><span class="line">- (UIViewController *)viewController:(UIView *)view&#123;</span><br><span class="line">    </span><br><span class="line">    UIResponder *responder = view;</span><br><span class="line">    while ((responder = [responder nextResponder]))</span><br><span class="line">    if ([responder isKindOfClass: [UIViewController class]])&#123;</span><br><span class="line">    return (UIViewController *)responder;</span><br><span class="line">    &#125;</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//最后，在你跳转页面的方法中</span><br><span class="line">superVC = [self viewController:self];</span><br><span class="line"> </span><br><span class="line">[superVC.navigationController pushViewController:（UIViewController） animated:YES];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这样就可以跳转页面了.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[tableView的性能优化]]></title>
      <url>http://nickchenhao.github.io./2016/06/02/tableView%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<h3 id="tableView性能优化"><a href="#tableView性能优化" class="headerlink" title="tableView性能优化"></a>tableView性能优化</h3><p>tableview的优化一直是一个很考验基本功的活儿，之前做项目的适合被这个问题困扰了很久，通过性能工具、查阅文档解决，整理思路和解决方案如下：</p>
<h4 id="tableview优化最主要：复用cell，header，footer实例；使用约束布局cell子控件时不多次添加约束；图片不过大，尽量不使用透明视图；避免阻塞主线程；计算高度方法不做大量逻辑处理。"><a href="#tableview优化最主要：复用cell，header，footer实例；使用约束布局cell子控件时不多次添加约束；图片不过大，尽量不使用透明视图；避免阻塞主线程；计算高度方法不做大量逻辑处理。" class="headerlink" title="tableview优化最主要：复用cell，header，footer实例；使用约束布局cell子控件时不多次添加约束；图片不过大，尽量不使用透明视图；避免阻塞主线程；计算高度方法不做大量逻辑处理。"></a>tableview优化最主要：复用cell，header，footer实例；使用约束布局cell子控件时不多次添加约束；图片不过大，尽量不使用透明视图；避免阻塞主线程；计算高度方法不做大量逻辑处理。</h4><ul>
<li>cell是否使用了复用机制而不是每一次都创建新的cell。</li>
</ul>
<p>如果每次都创建新的cell，在滑动的时候会表现为：刚开始的时候很顺畅，但是会越来越卡，内存跟着一直升高，停止滑动的时候也不会降下来。使用缓存机制创建的cell，开始滑动的时候内存会开始上升，等创建了一个屏幕再加半屏的cell之后，内存趋于平稳。<br><a id="more"></a></p>
<ul>
<li>cell是否添加了大量的子控件，或者对layer做了过多的操作。</li>
</ul>
<p>如果添加了大量的子控件，使用drawRect方法添加子控件，平衡GPU与CPU的负担。同时还需要注意尽量使用不透明视图和不重叠的渐变，否则会加大GPU的负担，造成性能不佳。</p>
<ul>
<li>高度计算方法时不做复杂的计算，尽量只使用加减乘除。</li>
</ul>
<p>自适应高度的cell实现方式有很多种，比如，</p>
<p>1.使用iOS7以上系统的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func tableView(tableView: UITableView, estimatedHeightForRowAtIndexPath indexPath: NSIndexPath) -&gt; CGFloat</span><br></pre></td></tr></table></figure>
<p>这个方法中，可以先给一个估计的高度，系统会从你给定的高度再去计算实际高度。但是在使用过程中会出现cell突然变高变得低的情况，不适用于高度变化太大的cell。</p>
<p>2.如果使用约束布局创建的cell子控件，子控件之间都建立了相互约束，最上面的子控件与cell顶部建立约束，最下面的子控件与cell底部建立了约束，相当于子控件把cell撑开了。</p>
<p>约束简图:<br><img src="/Users/nick/Desktop/1.jpeg" alt=""></p>
<p>这时在高度计算方法中，走一遍cell的loaddata方法后可以通过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func systemLayoutSizeFittingSize(targetSize: CGSize) -&gt; CGSize</span><br></pre></td></tr></table></figure>
<p>取得cell的size，进而得到cell高度。<br>通过这个方法获取的cell高度是十分精确的，只要创建好子控件的约束就能获得cell的size。比较不好的是只是这种方法会重走一遍cell的loaddata方法。除此之外在调用cell的loaddata之前需要得到cell的实例，实例创建的方式应该与cellForRow方法一样，优先从缓存池中取得。<br>这个方案可能会创建多个cell。如果能在内存汇总保存一份cell的实例就能解决这个问题了！我讲讲我实现的思路：<br>首先先注册cell,当缓存池中没有cell时系统会自动创建，有的话会直接取缓存中的cell返回给你。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">override func viewDidLodad() &#123;</span><br><span class="line">    tableView.registerClass(CardCell.self, forCellReuseIdentifier: ID)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用lazy创建一个cell实例，由于lazy 关键字，cell的创建只会执行一次</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lazy var cell:CardCell = &#123;</span><br><span class="line">      //已经注册过cell，当缓存池中没有cell时系统会自动创建，有的话会直接取缓存中的cell返回</span><br><span class="line">      let v = self.myTableView?.dequeueReusableCellWithIdentifier(self.ID) as! CardCell</span><br><span class="line">      return v</span><br><span class="line">      &#125;()</span><br></pre></td></tr></table></figure>
<p>通过懒加载的方式，只创建一次cell的实例，避免内存浪费。<br>接下来要做的步骤就是之前讲的，调用cell的loadData方法，计算高度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func tableView(tableView: UITableView, heightForRowAtIndexPath indexPath: NSIndexPath) -&gt; CGFloat &#123;</span><br><span class="line">  self.imageCell.loadData(d)    </span><br><span class="line">  let height:CGFloat = self.cell.contentView.systemLayoutSizeFittingSize(UILayoutFittingCompressedSize).height</span><br><span class="line">return height</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="之前查资料的时候还有用空间换取时间的方案："><a href="#之前查资料的时候还有用空间换取时间的方案：" class="headerlink" title="之前查资料的时候还有用空间换取时间的方案："></a>之前查资料的时候还有用空间换取时间的方案：</h4><p>1）在请求网络数据成功后就计算好高度并通过字典或者数组保存高度值，在高度方法中直接根据数组下标或者key值取得高度并返回。</p>
<p>2）还有建立一个frameModel的方法，与1中相似，只是获得网络数据后保存到frameModel中，在frameModel中定义一个类方法，通过获得的model值计算高度后返回。<br>避免快速滑动情况下开过多线程。<br>cell中的图片开线程异步加载，相信每个人都会想到。线程开过多了会造成资源浪费，内存开销过大。图片过多时可以不要一滚动就走cellForRow方法，可以在scrollview的代理方法中做限制，当滚动开始减速的时候才加载显示在当前屏幕上的cell（通过tableview的dragging和declearating两个状态也能判断）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell &#123;</span><br><span class="line">      var canLoad:Bool = !tableView.dragging &amp;&amp; !tableView.declearating</span><br><span class="line">      if  canLoad &#123;</span><br><span class="line">          //开始loaddata，异步加载图片</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>图片处理</li>
</ul>
<p>1）后台下载图片后再回主线程刷新UI，避免阻塞主线程。<br>2）图片过大回造成GPU负担过大，可以在图片下载后压缩尺寸后显示<br>3）避免对layer做过多的操作，尽量设置图片为不透明</p>
<h4 id="补充："><a href="#补充：" class="headerlink" title="补充："></a>补充：</h4><ul>
<li>简单的设置cornerRadius是不会影响性能的，但是设置了maskToBounds，会导致离屏渲染，应减少设置图层 maskToBounds = YES ，；</li>
<li>使用懒加载图片的方式避免重复下载图片，浪费资源。图片下载后并做压缩处理后将其保存到缓存中，下次加载此图片之前先从缓存中取，如果取不到该图片就在后台下载保存。</li>
<li>使用Core Graphics实现圆角等功能。</li>
<li>重写drawRect方法会离屏渲染，导致内存急剧上升，即使在这个方法里面不写一句代码，也会让内存升高。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[数据安全]]></title>
      <url>http://nickchenhao.github.io./2016/04/05/%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8/</url>
      <content type="html"><![CDATA[<h3 id="1-Base64"><a href="#1-Base64" class="headerlink" title="1.Base64"></a>1.Base64</h3><h4 id="1-Base64简单说明"><a href="#1-Base64简单说明" class="headerlink" title="1.Base64简单说明"></a>1.Base64简单说明</h4><pre><code>描述：Base64可以成为密码学的基石，非常重要。
特点：可以将任意的二进制数据进行Base64编码
结果：所有的数据都能被编码为并只用65个字符就能表示的文本文件。
65字符：A~Z a~z 0~9 + / =
对文件进行base64编码后文件数据的变化：编码后的数据~=编码前数据的4/3，会大1/3左右。
</code></pre><h4 id="2-命令行进行Base64编码和解码"><a href="#2-命令行进行Base64编码和解码" class="headerlink" title="2.命令行进行Base64编码和解码"></a>2.命令行进行Base64编码和解码</h4><pre><code>编码：base64 123.png -o 123.txt
解码：base64 123.txt -o test.png -D
</code></pre><a id="more"></a>
<h4 id="3-Base64编码原理"><a href="#3-Base64编码原理" class="headerlink" title="3.Base64编码原理"></a>3.Base64编码原理</h4><pre><code>1)将所有字符转化为ASCII码；
2)将ASCII码转化为8位二进制；
3)将二进制3个归成一组(不足3个在后边补0)共24位，再拆分成4组，每组6位；
4)统一在6位二进制前补两个0凑足8位；
5)将补0后的二进制转为十进制；
6)从Base64编码表获取十进制对应的Base64编码；
</code></pre><p>处理过程说明：<br>    a.转换的时候，将三个byte的数据，先后放入一个24bit的缓冲区中，先来的byte占高位。<br>    b.数据不足3byte的话，于缓冲区中剩下的bit用0补足。然后，每次取出6个bit，按照其值选择查表选择对应的字符作为编码后的输出。<br>    c.不断进行，直到全部输入数据转换完成。<br>    d.如果最后剩下两个输入数据，在编码结果后加1个“=”；<br>    e.如果最后剩下一个输入数据，编码结果后加2个“=”；<br>    f.如果没有剩下任何数据，就什么都不要加，这样才可以保证资料还原的正确性。</p>
<h4 id="4-实现"><a href="#4-实现" class="headerlink" title="4.实现"></a>4.实现</h4><pre><code>a.说明：
    1）从iOS7.0 开始，苹果就提供了base64的编码和解码支持
    2)如果是老项目，则还能看到base64编码和解码的第三方框架，如果当前不再支持iOS7.0以下版本，则建议替换。

b.相关代码：
//给定一个字符串，对该字符串进行Base64编码，然后返回编码后的结果
-(NSString *)base64EncodeString:(NSString *)string
{
    //1.先把字符串转换为二进制数据
    NSData *data = [string dataUsingEncoding:NSUTF8StringEncoding];

    //2.对二进制数据进行base64编码，返回编码后的字符串
    return [data base64EncodedStringWithOptions:0];
}

//对base64编码后的字符串进行解码
-(NSString *)base64DecodeString:(NSString *)string
{
    //1.将base64编码后的字符串『解码』为二进制数据
    NSData *data = [[NSData alloc]initWithBase64EncodedString:string options:0];

    //2.把二进制数据转换为字符串返回
    return [[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding];
}

c.终端测试命令
    $ echo -n A | base64
    $ echo -n QQ== |base64 -D
</code></pre><h3 id="2-常见的加密算法和其它"><a href="#2-常见的加密算法和其它" class="headerlink" title="2.常见的加密算法和其它"></a>2.常见的加密算法和其它</h3><ul>
<li>base64 编码格式</li>
<li>密码学演化 “秘密本”–&gt;RSA</li>
<li>常见的加密算法<ul>
<li>消息摘要（单向散列函数）</li>
<li>对称加密</li>
<li>非对称加密</li>
<li>证书等</li>
</ul>
</li>
</ul>
<h3 id="3-单向散列函数"><a href="#3-单向散列函数" class="headerlink" title="3.单向散列函数"></a>3.单向散列函数</h3><h4 id="1-单向散列函数的特点："><a href="#1-单向散列函数的特点：" class="headerlink" title="1.单向散列函数的特点："></a>1.单向散列函数的特点：</h4><pre><code>①加密后密文的长度是定长的
②如果明文不一样，那么散列后的结果一定不一样
③如果明文一样，那么加密后的密文一定一样（对相同数据加密，加密后的密文一样）
④所有的加密算法是公开的
⑤不可以逆推反算
</code></pre><h4 id="2-经典加密算法"><a href="#2-经典加密算法" class="headerlink" title="2.经典加密算法"></a>2.经典加密算法</h4><pre><code>1）MD5加密
2）SHA1
3）SHA512
</code></pre><h4 id="3-MD5加密算法简单说明"><a href="#3-MD5加密算法简单说明" class="headerlink" title="3.MD5加密算法简单说明"></a>3.MD5加密算法简单说明</h4><pre><code>1）对字符串进行MD5加密可以得到一个32个字符的密文
2）加密之后不能根据密文逆推出明文
3）MD5已经被破解（暴力破解|碰撞检测）
</code></pre><h4 id="4-MD5加密进阶"><a href="#4-MD5加密进阶" class="headerlink" title="4.MD5加密进阶"></a>4.MD5加密进阶</h4><pre><code>1）先加盐，然后再进行MD5
2）先乱序，再进行MD5加密
3）乱序|加盐，多次MD5加密等
4）使用消息认证机制，即HMAC-MD5-先对密钥进行加密，加密之后进行两次MD5散列
5）加密命令行
    MD5加密-字符串    $ echo -n &quot;520it&quot; |md5
    MD5加密-文件1     $ md5 abc.png
    SHA1加密：        $ echo -n &quot;520it&quot; |openssl sha -sha1
    SHA256            $ echo -n &quot;520it&quot; |openssl sha -sha256
    SHA512            $ echo -n &quot;520it&quot; |openssl sha -sha512
    hmacMD5加密       $ echo -n &quot;520it&quot; |openssl dgst -md5 -hmac &quot;123&quot;
</code></pre><h4 id="5-散列函数应用领域"><a href="#5-散列函数应用领域" class="headerlink" title="5.散列函数应用领域"></a>5.散列函数应用领域</h4><pre><code>1）搜索 多个关键字，先对每个关键字进行散列，然后多个关键字进行或运算，如果值一致则搜索结果一致
2）版权 对文件进行散列判断该文件是否是正版或原版的
3）文件完整性验证 对整个文件进行散列，比较散列值判断文件是否完整或被篡改
</code></pre><h4 id="6-消息认证机制（HMAC）简单说明"><a href="#6-消息认证机制（HMAC）简单说明" class="headerlink" title="6.消息认证机制（HMAC）简单说明"></a>6.消息认证机制（HMAC）简单说明</h4><pre><code>1）原理
    ①消息的发送者和接收者有一个共享密钥
    ②发送者使用共享密钥对消息加密计算得到MAC值（消息认证码）
    ③消息接收者使用共享密钥对消息加密计算得到MAC值
    ④比较两个MAC值是否一致
2）使用
    ①客户端需要在发送的时候把（消息）+（消息·HMAC）一起发送给服务器
    ②服务器接收到数据后，对拿到的消息用共享的KEY进行HMAC，比较是否一致，如果一致则信任
</code></pre><h3 id="4-对称加密"><a href="#4-对称加密" class="headerlink" title="4.对称加密"></a>4.对称加密</h3><h4 id="1-对称加密的特点"><a href="#1-对称加密的特点" class="headerlink" title="1.对称加密的特点"></a>1.对称加密的特点</h4><pre><code>1）加密/解密使用相同的密钥
2）加密和解密的过程是可逆的（明文-》明文-》明文）
</code></pre><h4 id="2-经典算法"><a href="#2-经典算法" class="headerlink" title="2.经典算法"></a>2.经典算法</h4><pre><code>1）DES 数据加密标准
2）3DES 使用3个密钥，对消息进行（密钥1·加密）+（密钥2·解密）+（密钥3·加密）
3）AES 高级加密标准
</code></pre><h4 id="3-分组密码简单说明"><a href="#3-分组密码简单说明" class="headerlink" title="3.分组密码简单说明"></a>3.分组密码简单说明</h4><pre><code>密码算法可以分为分组密码和流密码两种。
分组密码：每次只能处理特定长度的一zu数据的一类密码算法。一个分组的比特数量就称之为分组长度。
ex:DES和3DES的分组长度都是64比特。即每次只能加密64比特的明文，并生成64比特的密文。AES的分组长度有128比特、192比特和256比特可以选择。
流密码：对数据流进行连续处理的一类算法。流密码中一般以1比特、8比特或者是32比特等作为单位俩进行加密和解密。
</code></pre><h4 id="4-ECB分组模式"><a href="#4-ECB分组模式" class="headerlink" title="4.ECB分组模式"></a>4.ECB分组模式</h4><pre><code>ECB模式的全称为Electronic CodeBook模式。又成为电子密码本模式。
特点：
1）使用ECB模式加密的时候，相同的明文分组会被转换为相同的密文分组。
2）类似于一个巨大的明文分组-》密文分组的对照表。
</code></pre><p><img src="/Users/nick/Desktop/1.png" alt=""></p>
<pre><code>终端测试命令：
加密 $ openssl enc -des-ecb -K 616263 -nosalt -in 123.txt -out 123.bin
解密 $ openssl enc -des-ecb -K 616263 -nosalt -in 123.bin -out 1231.txt -d
</code></pre><h4 id="5-CBC分组模式"><a href="#5-CBC分组模式" class="headerlink" title="5.CBC分组模式"></a>5.CBC分组模式</h4><pre><code>CBC模式全称为Cipher Block Chainning模式（密文分组链接模式|电子密码链条）
特点：在CBC模式中，首先将明文分组与前一个密文分组进行XOR运算，然后再进行加密。


终端命令：
加密 $ openssl enc -des-cbc -K 616263 -iv 0102030405060708 -nosalt -in a.txt -out a.bin
解密 $ openssl enc -des-cbc -K 616263 -iv 0102030405060708 -nosalt -in a.bin -out a1.txt -d
</code></pre><h3 id="5-非对称加密"><a href="#5-非对称加密" class="headerlink" title="5.非对称加密"></a>5.非对称加密</h3><h4 id="1-非对称加密的特点"><a href="#1-非对称加密的特点" class="headerlink" title="1.非对称加密的特点"></a>1.非对称加密的特点</h4><pre><code>1）使用公钥加密，使用私钥解密
2）公钥是公开的，私钥保密
3）加密处理安全，但是性能极差
</code></pre><p><img src="/Users/nick/Desktop/2.png" alt=""></p>
<h4 id="2-经典算法—RSA"><a href="#2-经典算法—RSA" class="headerlink" title="2.经典算法—RSA"></a>2.经典算法—RSA</h4><pre><code>1）RSA 原理
    （1）求N，准备两个质数p和q,N = p x q
    （2）求L,L是p-1和q-1的最小公倍数。L = lcm（p-1,q-1）
    （3）求E，E和L的最大公约数为1（E和L互质）
    （4）求D，E x D mode L = 1
2）RSA加密小实践
    （1）p = 17,q = 19 =&gt;N = 323
    （2）lcm（p-1,q-1）=&gt;lcm（16，18）=&gt;L= 144
    （3）gcd（E,L）=1 =&gt;E=5
    （4）E乘以几可以mode L =1? D=29可以满足
    （5）得到公钥为：E=5,N=323
    （6）得到私钥为：D=29,N=323
    （7）加密 明文的E次方 mod N = 123的5次方 mod 323 = 225（密文）
    （8）解密 密文的D次方 mod N = 225的29次方 mod 323 = 123（明文）
    ----------------
3）openssl生成密钥命令
    生成强度是 512 的 RSA 私钥：$ openssl genrsa -out private.pem 512
    以明文输出私钥内容：$ openssl rsa -in private.pem -text -out private.txt
    校验私钥文件：$ openssl rsa -in private.pem -check
    从私钥中提取公钥：$ openssl rsa -in private.pem -out public.pem -outform PEM -pubout
    以明文输出公钥内容：$ openssl rsa -in public.pem -out public.txt -pubin -pubout -text
    使用公钥加密小文件：$ openssl rsautl -encrypt -pubin -inkey public.pem -in msg.txt -out msg.bin
    使用私钥解密小文件：$ openssl rsautl -decrypt -inkey private.pem -in msg.bin -out a.txt
    将私钥转换成 DER 格式：$ openssl rsa -in private.pem -out private.der -outform der
    将公钥转换成 DER 格式：$ openssl rsa -in public.pem -out public.der -pubin -outform der
    -----------------
</code></pre><h3 id="6-数字签名"><a href="#6-数字签名" class="headerlink" title="6.数字签名"></a>6.数字签名</h3><h4 id="1-数字签名的应用场景"><a href="#1-数字签名的应用场景" class="headerlink" title="1.数字签名的应用场景"></a>1.数字签名的应用场景</h4><pre><code>答：需要严格验证发送方身份信息情况
</code></pre><h4 id="2-数字签名原理"><a href="#2-数字签名原理" class="headerlink" title="2.数字签名原理"></a>2.数字签名原理</h4><pre><code>1）客户端处理
    ①对&quot;消息&quot;进行 HASH 得到 &quot;消息摘要&quot;
    ②发送方使用自己的私钥对&quot;消息摘要&quot; 加密(数字签名)
    ③把数字签名附着在&quot;报文&quot;的末尾一起发送给接收方
2）服务端处理
    ①对&quot;消息&quot; HASH 得到 &quot;报文摘要&quot;
    ②使用公钥对&quot;数字签名&quot; 解密
    ③对结果进行匹配
</code></pre><p><img src="/Users/nick/Desktop/3.png" alt=""></p>
<h3 id="7-数字证书"><a href="#7-数字证书" class="headerlink" title="7.数字证书"></a>7.数字证书</h3><h4 id="1-简单说明"><a href="#1-简单说明" class="headerlink" title="1.简单说明"></a>1.简单说明</h4><pre><code>证书和驾照很相似，里面记有姓名、组织、地址等个人信息，以及属于此人的公钥，并有认证机构施加数字签名,只要看到公钥证书，我们就可以知道认证机构认证该公钥的确属于此人
</code></pre><h4 id="2-数字证书的内容"><a href="#2-数字证书的内容" class="headerlink" title="2.数字证书的内容"></a>2.数字证书的内容</h4><pre><code>1）公钥
2）认证机构的数字签名
</code></pre><h4 id="3-证书的生成步骤"><a href="#3-证书的生成步骤" class="headerlink" title="3.证书的生成步骤"></a>3.证书的生成步骤</h4><pre><code>1）生成私钥 openssl genrsa -out private.pem 1024
2）创建证书请求 openssl req -new -key private.pem -out rsacert.csr
3）生成证书并签名，有效期10年 openssl x509 -req -days 3650 -in rsacert.csr -signkey private.pem -out rsacert.crt
4）将 PEM 格式文件转换成 DER 格式 openssl x509 -outform der -in rsacert.crt -out rsacert.der
5）导出P12文件 openssl pkcs12 -export -out p.p12 -inkey private.pem -in rsacert.crt
</code></pre><h4 id="4-iOS开发中的注意点"><a href="#4-iOS开发中的注意点" class="headerlink" title="4.iOS开发中的注意点"></a>4.iOS开发中的注意点</h4><pre><code>1）在iOS开发中，不能直接使用 PEM 格式的证书，因为其内部进行了Base64编码，应该使用的是DER的证书，是二进制格式的
2）OpenSSL默认生成的都是PEM格式的证书
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[siwft笔记3]]></title>
      <url>http://nickchenhao.github.io./2016/01/27/siwft%E7%AC%94%E8%AE%B03/</url>
      <content type="html"><![CDATA[<h3 id="一-三大特性"><a href="#一-三大特性" class="headerlink" title="一.三大特性"></a>一.三大特性</h3><ul>
<li>封装</li>
<li>继承<ul>
<li>重写父类方法 需要加上 override</li>
</ul>
</li>
<li><p>多态</p>
<ul>
<li>必须要有继承</li>
<li>必须要有重写</li>
<li>必须是父类指针指向子类对象</li>
</ul>
</li>
<li>(重载)<ul>
<li>参数类型不同</li>
<li>参数个数不同</li>
</ul>
</li>
</ul>
<h3 id="二-自动引用计数"><a href="#二-自动引用计数" class="headerlink" title="二.自动引用计数"></a>二.自动引用计数</h3><ul>
<li>当有一个强引用指向某个对象时,该对象的引用计数会自动 + 1</li>
<li>当强引用消失时,引用计数会自动 - 1</li>
<li><p>当引用计数为0时,该对象会被销毁</p>
<a id="more"></a>
<h5 id="循环引用-的解决"><a href="#循环引用-的解决" class="headerlink" title="循环引用 的解决"></a>循环引用 的解决</h5><pre><code>1.weak       和OC中的 __weak一样 是弱引用  当指向的对象销毁时,会自动指向nil
2.unowned    和OC中的 __unsefe_unretained   当对象销毁时依然指向原来的位置(容易引起野指针)
</code></pre></li>
</ul>
<h3 id="三-可选链"><a href="#三-可选链" class="headerlink" title="三.可选链"></a>三.可选链</h3><ul>
<li>如果可选的目标有值,就调用成功</li>
<li>如果没有值,则调用返回空nil  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   // OC对象结构体的成员属性不能直接赋值</span><br><span class="line">   titleLabel?.frame.origin.x = 0</span><br></pre></td></tr></table></figure>
<h3 id="四-协议-protocol"><a href="#四-协议-protocol" class="headerlink" title="四.协议  protocol"></a>四.协议  protocol</h3><ul>
<li><h5 id="定义协议和遵守协议"><a href="#定义协议和遵守协议" class="headerlink" title="定义协议和遵守协议"></a>定义协议和遵守协议</h5></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 1.定义协议</span><br><span class="line">protocol SportProtocol &#123; </span><br><span class="line">     func playBasketball() </span><br><span class="line">     func playFootball()</span><br><span class="line">&#125;</span><br><span class="line">// 2.遵守协议</span><br><span class="line">// 注意:默认情况下在swift中所有的协议方法都是必须实现的,如果不实现,则编译器会报错</span><br><span class="line">class Person : SportProtocol &#123; </span><br><span class="line">     var name : String? var age : Int = 0</span><br><span class="line">   // 实现协议中的方法 </span><br><span class="line">     func playBasketball() &#123; </span><br><span class="line">         print(&quot;人在打篮球&quot;) </span><br><span class="line">     &#125;</span><br><span class="line">     func playFootball() &#123; </span><br><span class="line">         print(&quot;人在踢足球&quot;) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h5 id="协议之间的继承"><a href="#协议之间的继承" class="headerlink" title="协议之间的继承"></a>协议之间的继承</h5></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">protocol CrazySportProtocol &#123;      </span><br><span class="line">      func jumping()</span><br><span class="line">&#125;</span><br><span class="line">protocol SportProtocol : CrazySportProtocol &#123;</span><br><span class="line">     func playBasketball()   </span><br><span class="line">     func playFootball()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><h5 id="协议中方法的可选-需加-objc-和-optional-关键字"><a href="#协议中方法的可选-需加-objc-和-optional-关键字" class="headerlink" title="协议中方法的可选  需加 @objc 和 optional 关键字"></a>协议中方法的可选  需加 @objc 和 optional 关键字</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 1.定义协议</span><br><span class="line">@objc</span><br><span class="line">protocol SportProtocol &#123;</span><br><span class="line">    func playBasketball()</span><br><span class="line">    optional func playFootball()</span><br><span class="line">&#125;</span><br><span class="line">// 2.遵守协议</span><br><span class="line">class Person : SportProtocol &#123;</span><br><span class="line">    var name : String?</span><br><span class="line">    var age : Int = 0</span><br><span class="line">    // 实现协议中的方法</span><br><span class="line">    @objc func playBasketball() &#123;</span><br><span class="line">        print(&quot;人在打篮球&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="代理协议"><a href="#代理协议" class="headerlink" title="代理协议"></a>代理协议</h5></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">1.定义协议属性 用 weak 且协议后面需 : class 才不会报错</span><br><span class="line">protocol BuyTicketProtocol : class &#123;</span><br><span class="line">    func buyTicket()&#125;class Person &#123;    // 1.定义协议属性</span><br><span class="line">    weak var delegate : BuyTicketProtocol</span><br><span class="line">    func goToHeFei()&#123;</span><br><span class="line">        delegate?.buyTicketing()</span><br><span class="line">        print(&quot;去北京&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;class Huangniu: BuyTicketDelegate &#123;</span><br><span class="line">    func buyTicketing() &#123;</span><br><span class="line">        print(&quot;买票&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//代理对象</span><br><span class="line">//设置代理时 没有self   需要先 let 创建代理对象  然后再 设置代理 = 代理对象</span><br><span class="line">let h = Huangniu()</span><br><span class="line">let p = Person()</span><br><span class="line">p.delegate = h</span><br><span class="line">p.goToHeFei()</span><br></pre></td></tr></table></figure>
<h3 id="五-闭包-类似OC中的Block"><a href="#五-闭包-类似OC中的Block" class="headerlink" title="五.闭包 (类似OC中的Block)"></a>五.闭包 (类似OC中的Block)</h3><ul>
<li>block的写法:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    类型:    返回值(^block的名称)(block的参数)</span><br><span class="line">    值:</span><br><span class="line">    ^(参数列表) &#123;</span><br><span class="line">        // 执行的代码</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>闭包的写法:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    类型:(形参列表)-&gt;(返回值)</span><br><span class="line">    技巧:初学者定义闭包类型,直接写()-&gt;().再填充参数和返回值</span><br><span class="line">    值:</span><br><span class="line">    &#123;</span><br><span class="line">        (形参) -&gt; 返回值类型 in</span><br><span class="line">        // 执行代码</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>闭包的循环引用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> 需要用到self的地方:</span><br><span class="line">     1.如果某一个方法中,有局部变量和成员变量产生歧义,可以使用self进行区分</span><br><span class="line">     2.如果在闭包中使用到当前对象的方法或者属性,都需要加self</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">// 解决方案一:</span><br><span class="line">        weak var weakself : ViewController? = self</span><br><span class="line">        httpTool?.loadData(&#123; (jsonData) -&gt; () in</span><br><span class="line">        weakself?.view.backgroundColor = UIColor.redColor()</span><br><span class="line">        &#125;)</span><br><span class="line">// 解决方案二:(推荐)</span><br><span class="line">        httpTool?.loadData(&#123;[weak self] (jsonData) -&gt; () in            self?.view.backgroundColor = UIColor.redColor()</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>
<h3 id="六-懒加载"><a href="#六-懒加载" class="headerlink" title="六.懒加载"></a>六.懒加载</h3><ul>
<li>格式</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lazy var 变量: 类型 = &#123; 创建变量代码 &#125;()</span><br></pre></td></tr></table></figure>
<ul>
<li>懒加载的使用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 懒加载的本质是,在第一次使用的时候执行闭包,将闭包的返回值赋值给属性</span><br><span class="line">// lazy的作用是只会赋值一次</span><br><span class="line">    lazy var array : [String] = &#123;</span><br><span class="line">        return [&quot;why&quot;, &quot;lmj&quot;, &quot;lnj&quot;]</span><br><span class="line">    &#125;()</span><br><span class="line">     lazy var btn : UIButton = &#123;</span><br><span class="line">        let tempBtn = UIButton()</span><br><span class="line">        tempBtn.setTitle(&quot;按钮&quot;, forState: .Normal)</span><br><span class="line">        return tempBtn</span><br><span class="line">    &#125;()</span><br></pre></td></tr></table></figure>
<h3 id="七-常见注释"><a href="#七-常见注释" class="headerlink" title="七.常见注释"></a>七.常见注释</h3><ul>
<li>单行注释 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 注释内容</span><br></pre></td></tr></table></figure>
<ul>
<li>多行注释 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/* </span><br><span class="line">(与OC不同  可以多行嵌套多行注释) </span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<ul>
<li>文档注释 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 注释内容</span><br></pre></td></tr></table></figure>
<ul>
<li>分组注释</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// MARK:-</span><br></pre></td></tr></table></figure>
<h3 id="八-访问权限"><a href="#八-访问权限" class="headerlink" title="八.访问权限"></a>八.访问权限</h3><ul>
<li>Swift 中的访问控制模型基于模块和源文件这两个概念</li>
<li>private : 修饰源文件,在当前源文件中可以访问</li>
<li>internal : 内部的,修饰整个项目,在整个项目中都可以进行访问,并且默认修饰的就是internal</li>
<li>public :  修饰整个项目,可以跨框架使用<br>(在class 和 func前面加)</li>
</ul>
<h3 id="九-处理异常-三种方式"><a href="#九-处理异常-三种方式" class="headerlink" title="九.处理异常  (三种方式)"></a>九.处理异常  (三种方式)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 3.异常的处理三种方式</span><br><span class="line">// 3.1.try方式,需要手动处理异常do &#123;</span><br><span class="line">    let result = try readFileContent(&quot;abc&quot;)&#125; catch &#123;</span><br><span class="line">    print(error)&#125;</span><br><span class="line">// 3.2.try?方式,不处理异常,如果出现了异常,则返回一个nil.没有异常,则返回对应的值</span><br><span class="line">// 最终返回结果为一个可选类型let result = try? readFileContent(&quot;abc&quot;)</span><br><span class="line">// 3.3.try!方法,告诉系统该方法没有异常.</span><br><span class="line">// 注意:如果出现了异常,则程序会崩溃</span><br><span class="line">    let result = try! readFileContent(&quot;abc&quot;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">示例</span><br><span class="line">// 1.定义异常enum FileReadError : ErrorType &#123;</span><br><span class="line">    case FileISNull</span><br><span class="line">    case FileNotFound</span><br><span class="line">&#125;</span><br><span class="line">// 2.改进方法,让方法抛出异常</span><br><span class="line">func readFileContent(filePath : String) throws -&gt; String &#123;</span><br><span class="line">    // 1.filePath为&quot;&quot;</span><br><span class="line">    if filePath == &quot;&quot; &#123;</span><br><span class="line">        throw FileReadError.FileISNull</span><br><span class="line">    &#125;</span><br><span class="line">    // 2.filepath有值,但是没有对应的文件  </span><br><span class="line">    if filePath != &quot;/User/Desktop/123.plist&quot; &#123;        throw FileReadError.FileISNull    &#125;    // 3.取出其中的内容    return &quot;123&quot;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="十-桥接"><a href="#十-桥接" class="headerlink" title="十.桥接"></a>十.桥接</h3><ul>
<li>OC调用swift</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.直接写入一个头文件:  项目名字-Swift.h      </span><br><span class="line">#import &quot;项目名字-Swift.h&quot;</span><br><span class="line"></span><br><span class="line">2.在swift中 添加public关键字 在class和func前面</span><br><span class="line"> (还是以OC格式书写)</span><br></pre></td></tr></table></figure>
<ul>
<li>swift调用OC</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.建立桥接文件  Bridge.h  里面放 .h头文件</span><br><span class="line">2.在项目中Build Settings 配置文件  搜索bird  </span><br><span class="line">然后将Bridge.h路径存入(类似PCH文件)</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[swift笔记2]]></title>
      <url>http://nickchenhao.github.io./2016/01/26/swift%E7%AC%94%E8%AE%B02/</url>
      <content type="html"><![CDATA[<h3 id="字符串的介绍"><a href="#字符串的介绍" class="headerlink" title="字符串的介绍"></a>字符串的介绍</h3><ul>
<li>字符串在任何的开发中使用都是非常频繁的</li>
<li>OC和Swift中字符串的区别<ul>
<li>在OC中字符串类型时NSString,在Swift中字符串类型是String</li>
<li>OC中字符串@””,Swift中字符串””</li>
</ul>
</li>
<li><p>使用 String 的原因</p>
<ul>
<li>String 是一个结构体，性能更高</li>
<li>NSString 是一个 OC 对象，性能略差</li>
<li>String 支持直接遍历</li>
<li>Swift 提供了 String 和 NSString 之间的无缝转换</li>
</ul>
<a id="more"></a>
</li>
</ul>
<h3 id="字符的定义"><a href="#字符的定义" class="headerlink" title="字符的定义"></a>字符的定义</h3><ul>
<li><p>定义不可变字符串<br><code>let str = &quot;hello Objective-C&quot;</code></p>
</li>
<li><p>定义可变字符串<br><code>var str = &quot;hello Swift&quot;</code></p>
</li>
</ul>
<h3 id="字符串的使用"><a href="#字符串的使用" class="headerlink" title="字符串的使用"></a>字符串的使用</h3><p>获取字符串的长度</p>
<ul>
<li><p>获取字符集合,再获取集合的count属性<br><code>let count = str.characters.count</code></p>
</li>
<li><p>遍历字符串</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var str = &quot;Hello, Swift&quot;</span><br><span class="line">for c in str.characters &#123;</span><br><span class="line">    print(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><ul>
<li>两个字符串的拼接</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let str1 = &quot;Hello&quot;</span><br><span class="line">let str2 = &quot;World&quot;</span><br><span class="line">let str3 = str1 + str2</span><br></pre></td></tr></table></figure>
<ul>
<li>字符串和其他数据类型的拼接</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let name = &quot;why&quot; </span><br><span class="line">let age = 18 </span><br><span class="line">let info = &quot;my name is \(name), age is \(age)&quot; </span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">- 字符串的格式化</span><br><span class="line"> - 比如时间:03:04</span><br></pre></td></tr></table></figure>
<p>   let min = 3<br>   let second = 4<br>   let time = String(format: “%02d:%02d”, arguments: [min, second])<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">###字符串的截取</span><br><span class="line"></span><br><span class="line">- Swift中提供了特殊的截取方式</span><br><span class="line"> - 该方式非常麻烦</span><br><span class="line"> - Index创建较为麻烦</span><br><span class="line">- 简单的方式是将String转成NSString来使用</span><br><span class="line"> - 在标识符后加:as NSString即可</span><br></pre></td></tr></table></figure></p>
<p>let myStr = “www.520it.com”<br>var subStr = (myStr as NSString).substringFromIndex(4)<br>subStr = (myStr as NSString).substringToIndex(3)<br>subStr = (myStr as NSString).substringWithRange(NSRange(location: 4, length: 5))<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- swift截取方式</span><br></pre></td></tr></table></figure></p>
<p>// 1.定义字符串<br>let str = “www.520it.com”</p>
<p>// 2.截取开始位置<br>let fromIndex = str.startIndex.advancedBy(3)<br>let header = str.substringFromIndex(fromIndex)</p>
<p>// 3.截取结束位置<br>let toIndex = str.endIndex.advancedBy(-3)<br>let footer = str.substringToIndex(toIndex)</p>
<p>// 4.截取中间的字符串<br>let range = Range(start: str.startIndex.advancedBy(4), end: str.endIndex.advancedBy(-4))<br>let middle = str.substringWithRange(range)<br>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[swift笔记1]]></title>
      <url>http://nickchenhao.github.io./2016/01/25/swift/</url>
      <content type="html"><![CDATA[<h2 id="Swift最基本的语法变化"><a href="#Swift最基本的语法变化" class="headerlink" title="Swift最基本的语法变化"></a>Swift最基本的语法变化</h2><ul>
<li>导入框架 import UIKit</li>
<li><p>定义标识符时，必须声明该标识符是变量还是常量声明标识符的<br>格式:变量/常量关键字 名称 : 数据类型</p>
</li>
<li><p>语句结束时不需要加 ;如果同一行有多个语句,则依然需要加<br>但是不建议一行多条语句</p>
</li>
<li><p>Swift中的打印语句: print(“打印的内容”)</p>
<a id="more"></a>
<h2 id="什么是常量和变量"><a href="#什么是常量和变量" class="headerlink" title="什么是常量和变量"></a>什么是常量和变量</h2></li>
<li><p>在Swift中规定:在定义一个标识符时必须明确说明该标识符是一个常量还是变量<br>1.使用let来定义常量,定义之后不可以修改<br>2.使用var来定义变量,定义之后可以修改</p>
</li>
</ul>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h4><p>在真实使用过程中,建议先定义常量,如果需要修改再修改为变量(更加安全)<br>是指向的对象不可以再进行修改.但是可以通过指针获得对象后,修改对象内部的属性</p>
<h3 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h3><p>Swift是强类型的语言<br>Swift中任何一个标识符都有明确的类型</p>
<h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意:"></a>注意:</h4><p>1.如果定义一个标识符时有直接进行赋值,那么标识符后面的类型可以省略.<br>2.因为Swift有类型推导,会自动根据后面的赋值来决定前面的标识符的数据类型 可以通过option+鼠标左键 来查看变量的数据类型 </p>
<h2 id="Swift中基本运算"><a href="#Swift中基本运算" class="headerlink" title="Swift中基本运算"></a>Swift中基本运算</h2><p>1.Swift中在进行基本运算时必须保证类型一致,否则会出错相同类型之间才可以进行运算<br>因为Swift中没有隐式转换</p>
<p>2.数据类型的转化Int类型转成Double类型:Double(标识符)<br>Double类型转成Int类型:Int(标识符)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let a = 10</span><br><span class="line">let b = 3.14</span><br><span class="line">// 错误写法 </span><br><span class="line">//let c = a + b </span><br><span class="line">//let c = a * b</span><br><span class="line">// 正确写法</span><br><span class="line">let c = Double(a) + blet </span><br><span class="line">d = a + Int(b)</span><br></pre></td></tr></table></figure>
<p>if分支语句<br>和OC中if语句有一定的区别判断句可以不加()<br>在Swift的判断句中必须有明确的真假不再有非0即真<br>必须有明确的Bool值<br>Bool有两个取值:false/true</p>
<h2 id="guard的使用"><a href="#guard的使用" class="headerlink" title="guard的使用"></a>guard的使用</h2><p>guard语句必须带有else语句，它的语法如下：当条件表达式为true时候跳过else语句中的内容，执行语句组内容<br>条件表达式为false时候执行else语句中的内容，跳转语句一般是return、break、continue和throw</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">guard 条件表达式 else &#123;  // 条换语句 </span><br><span class="line">  break&#125;</span><br><span class="line">语句组</span><br></pre></td></tr></table></figure>
<h2 id="switch分支"><a href="#switch分支" class="headerlink" title="switch分支"></a>switch分支</h2><p>基本用法和OC用法一致<br>不同之处:switch后可以不跟()<br>case后可以不跟break(默认会有break)</p>
<h4 id="简单使用补充"><a href="#简单使用补充" class="headerlink" title="简单使用补充:"></a>简单使用补充:</h4><p>1.一个case判断中,可以判断多个值<br>多个值以, 隔开 如果希望出现之前的case穿透,则可以使用关键字fallthrough</p>
<p>2.什么是区间?通常我们指的是数字区间:0~10,100~200</p>
<p>3.swift中的区间常见有两种半开半闭区间:0..&lt;10 表示:0~9,不包括10<br>闭区间:0…10 表示:0~10</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let score = 88switch score &#123;</span><br><span class="line">    case 0..&lt;60:    </span><br><span class="line">        print(&quot;不及格&quot;)</span><br><span class="line">    case 60..&lt;80:    </span><br><span class="line">        print(&quot;几个&quot;)</span><br><span class="line">    case 80..&lt;90:    </span><br><span class="line">        print(&quot;良好&quot;)</span><br><span class="line">    case 90..&lt;100:    </span><br><span class="line">        print(&quot;优秀&quot;)</span><br><span class="line">    default:   </span><br><span class="line">        print(&quot;满分&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="循环的介绍"><a href="#循环的介绍" class="headerlink" title="循环的介绍"></a>循环的介绍</h2><ul>
<li>在开发中经常会需要循环</li>
<li>常见的循环有:for/while/do while.</li>
<li>这里我们只介绍for/while,因为for/while最常见</li>
</ul>
<h2 id="for循环的写法"><a href="#for循环的写法" class="headerlink" title="for循环的写法"></a>for循环的写法</h2><ul>
<li>最常规写法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 传统写法</span><br><span class="line">for var i = 0; i &lt; 10; i++ &#123; </span><br><span class="line">     print(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>区间for循环</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//半开半闭区间</span><br><span class="line">for i in 0..&lt;10 &#123; </span><br><span class="line">    print(i)</span><br><span class="line">&#125;</span><br><span class="line">//闭区间</span><br><span class="line">for i in 0...10 &#123; </span><br><span class="line">    print(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>特殊写法如果在for循环中不需要用到下标i</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for _ in 0..&lt;10 &#123; </span><br><span class="line">    print(&quot;hello&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="while和do-while循环"><a href="#while和do-while循环" class="headerlink" title="while和do while循环"></a>while和do while循环</h2><ul>
<li>while循环<ul>
<li>while的判断句必须有正确的真假,没有非0即真</li>
<li>while后面的()可以省略</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = 0</span><br><span class="line">while a &lt; 10 &#123; </span><br><span class="line">    a++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>do while循环使用<ul>
<li>repeat关键字来代替了do</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let b = 0</span><br><span class="line">repeat &#123; </span><br><span class="line">    print(b)</span><br><span class="line">    b++</span><br><span class="line">&#125; while b &lt; 20</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
  
  
</search>
