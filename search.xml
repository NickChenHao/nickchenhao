<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[SDWebImage初探]]></title>
    <url>%2F2019%2F06%2F12%2FSDWebImage%E5%88%9D%E7%BA%A7%E7%A0%94%E7%A9%B6%2F</url>
    <content type="text"><![CDATA[记录一下SDWebImage第三方源码的研究 流程图 流程说明 12345首先会在 SDWebImageCache 中寻找图片是否有对应的缓存, 它会以url 作为数据的索引先在内存中寻找是否有对应的缓存如果缓存未找到就会利用通过MD5处理过的key来继续在磁盘中查询对应的数据, 如果找到了, 就会把磁盘中的数据加载到内存中，并将图片显示出来如果在内存和磁盘缓存中都没有找到，就会向远程服务器发送请求，开始下载图片下载后的图片会加入缓存中，并写入磁盘中整个获取图片的过程都是在子线程中执行，获取到图片后回到主线程将图片显示出来 核心代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980//下载图片的核心方法/* * url 图片的二进制数据 * placeholder UIImageView的占位图片 * options 图片下载选项（策略） * progressBlock 进度回调 * completedBlock 完成回调 */- (void)sd_setImageWithURL:(NSURL *)url placeholderImage:(UIImage *)placeholder options:(SDWebImageOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageCompletionBlock)completedBlock &#123; // 取消当前图像下载 [self sd_cancelCurrentImageLoad]; // 利用运行时retain url objc_setAssociatedObject(self, &amp;imageURLKey, url, OBJC_ASSOCIATION_RETAIN_NONATOMIC); //判断，如果传入的下载策略不是延迟显示占位图片，那么在主线程中设置占位图片 if (!(options &amp; SDWebImageDelayPlaceholder)) &#123; dispatch_main_async_safe(^&#123; // 设置占位图像 self.image = placeholder; &#125;); &#125; //如果url不为空 if (url) &#123; // check if activityView is enabled or not //检查activityView是否可用 if ([self showActivityIndicatorView]) &#123; [self addActivityIndicator]; &#125; __weak __typeof(self)wself = self; // 实例化 SDWebImageOperation 操作 id &lt;SDWebImageOperation&gt; operation = [SDWebImageManager.sharedManager downloadImageWithURL:url options:options progress:progressBlock completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123; //移除UIActivityIndicatorView [wself removeActivityIndicator]; if (!wself) return; //下面block中的操作在主线程中处理 dispatch_main_sync_safe(^&#123; if (!wself) return; //如果图片下载完成，且传入的下载选项为手动设置图片则直接执行completedBlock回调，并返回 if (image &amp;&amp; (options &amp; SDWebImageAvoidAutoSetImage) &amp;&amp; completedBlock) &#123; completedBlock(image, error, cacheType, url); return; &#125; else if (image) &#123; //否则，如果图片存在，则设置图片到UIImageView上面，并刷新重绘视图 wself.image = image; [wself setNeedsLayout]; &#125; else &#123; //如果没有得到图像 //如果传入的下载选项为延迟显示占位图片，则设置占位图片到UIImageView上面，并刷新重绘视图 if ((options &amp; SDWebImageDelayPlaceholder)) &#123; wself.image = placeholder; [wself setNeedsLayout]; &#125; &#125; if (completedBlock &amp;&amp; finished) &#123; completedBlock(image, error, cacheType, url); &#125; &#125;); &#125;]; [self sd_setImageLoadOperation:operation forKey:@&quot;UIImageViewImageLoad&quot;]; &#125; else &#123; //如果url为空，则在主线中处理下面的操作 dispatch_main_async_safe(^&#123; //移除UIActivityIndicatorView [self removeActivityIndicator]; //处理错误信息，并执行任务结束回调，把错误信息作为参数传递出去 NSError *error = [NSError errorWithDomain:SDWebImageErrorDomain code:-1 userInfo:@&#123;NSLocalizedDescriptionKey : @&quot;Trying to load a nil url&quot;&#125;]; if (completedBlock) &#123; completedBlock(nil, error, SDImageCacheTypeNone, url); &#125; &#125;); &#125;&#125; 补充：项目中可能有以下两种需求一、图片进过加密处理，一段时间内可以访问，即图片地址后面跟的参数不同，但加载出来的图片是同一张，为了不重复下载，如何过滤图片地址？123456789101112131415161718方法： 写在viewDidLoad 或者 appDelegate里1.SD老版本写法// URL过滤器 [[SDWebImageManager sharedManager] setCacheKeyFilter:^NSString * _Nullable(NSURL * _Nullable url) &#123; // 去除参数 ？后面的 url = [[NSURL alloc] initWithScheme:url.scheme host:url.host path:url.path]; return [url relativeString]; &#125;]; 2.SD新版本写法// URL过滤器 SDWebImageCacheKeyFilter *filter = [[SDWebImageCacheKeyFilter alloc] initWithBlock:^NSString * _Nullable(NSURL * _Nonnull url) &#123; // 去除参数 ？后面的 url = [[NSURL alloc] initWithScheme:url.scheme host:url.host path:url.path]; return [url relativeString]; &#125;]; [[SDWebImageManager sharedManager] setCacheKeyFilter:filter]; 二、如何做到tableView滚动时 不加载cell中的图片，停止滚动或减速时才加图片？ 需要用到的核心方法：12345678910111213 * 根据图片的url下载图片并设置到ImageView上面去，占位图片 * 异步下载并缓存 * * @param url 图片的URL * @param placeholder 显示在UIImageView上面的占位图片，直到图片下载完成 * @param options 下载图片的选项。参考SDWebImageOptions的枚举值 * @param completedBlock 当操作执行完毕之后的回调。该回调没有返回值 * 第一个参数为请求的图片 * 第二个参数是NSError类型的，如果图片下载成功则error为nil,否则error有值 * 第三个参数是图片缓存的使用情况（内存缓存|沙盒缓存|直接下载） * 第四个参数是图片的URL地址 */- (void)sd_setImageWithURL:(NSURL *)url placeholderImage:(UIImage *)placeholder options:(SDWebImageOptions)options completed:(SDWebImageCompletionBlock)completedBlock; SDWebImageOptions 枚举类型：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117//使用位移枚举，通过按位与&amp;按位或|的组合方式传递多个值typedef NS_OPTIONS(NSUInteger, SDWebImageOptions) &#123; /** * By default, when a URL fail to be downloaded, the URL is blacklisted so the library won&apos;t keep trying. * This flag disable this blacklisting. * * 默认情况下，如果一个url在下载的时候失败了，那么这个url会被加入黑名单，不会尝试再次下载。如果使用该参数，则该URL不会被添加到黑名单中。意味着会对下载失败的URL尝试重新下载。 * 此标记取消黑名单 */ SDWebImageRetryFailed = 1 &lt;&lt; 0, //失败后尝试重新下载 /** * By default, image downloads are started during UI interactions, this flags disable this feature, * leading to delayed download on UIScrollView deceleration for instance. * * 默认情况下，在 UI 交互时也会启动图像下载，此标记取消这一特性 * 会推迟到滚动视图停止滚动之后再继续下载 * 备注：NSURLConnection 的网络下载事件监听的运行循环模式是 NSDefaultRunLoopMode */ SDWebImageLowPriority = 1 &lt;&lt; 1,//低优先级 /** * This flag disables on-disk caching * * 使用该参数，将禁止磁盘缓存，只做内存缓存 */ SDWebImageCacheMemoryOnly = 1 &lt;&lt; 2,//只使用内存缓存 /** * This flag enables progressive download, the image is displayed progressively during download as a browser would do. * By default, the image is only displayed once completely downloaded. * * 此标记允许渐进式下载，就像浏览器中那样，下载过程中，图像会逐步显示出来 * 默认情况下，图像会在下载完成后一次性显示 */ SDWebImageProgressiveDownload = 1 &lt;&lt; 3,//渐进式下载 /** * Even if the image is cached, respect the HTTP response cache control, and refresh the image from remote location if needed. * The disk caching will be handled by NSURLCache instead of SDWebImage leading to slight performance degradation. * This option helps deal with images changing behind the same request URL, e.g. Facebook graph api profile pics. * If a cached image is refreshed, the completion block is called once with the cached image and again with the final image. * * Use this flag only if you can&apos;t make your URLs static with embedded cache busting parameter. * * 遵守 HTPP 响应的缓存控制，如果需要，从远程刷新图像 * 磁盘缓存将由 NSURLCache 处理，而不是 SDWebImage，这会对性能有轻微的影响 * 此选项用于处理URL指向图片发生变化的情况 * 如果缓存的图像被刷新，会调用一次 completion block，并传递最终的图像 */ SDWebImageRefreshCached = 1 &lt;&lt; 4, //刷新缓存 /** * In iOS 4+, continue the download of the image if the app goes to background. This is achieved by asking the system for * extra time in background to let the request finish. If the background task expires the operation will be cancelled. * * 如果系统版本是iOS 4+的，那么当App进入后台后仍然会继续下载图像。 * 这是向系统请求额外的后台时间以保证下载请求完成的 * 如果后台任务过期，请求将会被取消 */ SDWebImageContinueInBackground = 1 &lt;&lt; 5, //后台下载 /** * Handles cookies stored in NSHTTPCookieStore by setting * NSMutableURLRequest.HTTPShouldHandleCookies = YES; * * 通过设置，处理保存在 NSHTTPCookieStore 中的 cookies */ SDWebImageHandleCookies = 1 &lt;&lt; 6, //处理保存在NSHTTPCookieStore中的cookies /** * Enable to allow untrusted SSL certificates. * Useful for testing purposes. Use with caution in production. * * 允许不信任的 SSL 证书 * 可以出于测试目的使用，在正式产品中慎用 */ SDWebImageAllowInvalidSSLCertificates = 1 &lt;&lt; 7, //允许不信任的 SSL 证书 /** * By default, image are loaded in the order they were queued. This flag move them to * the front of the queue and is loaded immediately instead of waiting for the current queue to be loaded (which * could take a while). * * 默认情况下，图像会按照添加到队列中的顺序被加载，此标记会将它们移动到队列前端被立即加载 * 而不是等待当前队列被加载，因为等待队列加载会需要一段时间 */ SDWebImageHighPriority = 1 &lt;&lt; 8, //高优先级（优先下载） /** * By default, placeholder images are loaded while the image is loading. This flag will delay the loading * of the placeholder image until after the image has finished loading. * * 默认情况下，在加载图像时，占位图像已经会被加载。 * 此标记会延迟加载占位图像，直到图像已经完成加载 */ SDWebImageDelayPlaceholder = 1 &lt;&lt; 9, //延迟占位图片 /** * We usually don&apos;t call transformDownloadedImage delegate method on animated images, * as most transformation code would mangle it. * Use this flag to transform them anyway. * * 通常不会在可动画的图像上调用transformDownloadedImage代理方法，因为大多数转换代码会破坏动画文件 * 使用此标记尝试转换 */ SDWebImageTransformAnimatedImage = 1 &lt;&lt; 10, //转换动画图像 /** * By default, image is added to the imageView after download. But in some cases, we want to * have the hand before setting the image (apply a filter or add it with cross-fade animation for instance) * Use this flag if you want to manually set the image in the completion when success * * 下载完成后手动设置图片，默认是下载完成后自动放到ImageView上 */ SDWebImageAvoidAutoSetImage = 1 &lt;&lt; 11 //手动设置图像&#125;; 参数填成以下就可以了1options: SDWebImageRetryFailed |SDWebImageLowPriority]]></content>
      <categories>
        <category>第三方框架</category>
      </categories>
      <tags>
        <tag>SDWebImage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[发布过程的问题]]></title>
    <url>%2F2017%2F01%2F23%2F%E5%8F%91%E5%B8%83%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[发布时遇到的一些问题iOS10 之后需要添加info.plist文件配置:12345678910 &lt;key&gt;NSBluetoothPeripheralUsageDescription&lt;/key&gt; &lt;string&gt;亲啊，打开蓝牙可以吗？&lt;/string&gt; &lt;key&gt;NSCameraUsageDescription&lt;/key&gt; &lt;string&gt;亲啊，打开相机可以吗？&lt;/string&gt; &lt;key&gt;NSContactsUsageDescription&lt;/key&gt; &lt;string&gt;亲啊，打开通讯录可以吗？&lt;/string&gt; &lt;key&gt;NSMicrophoneUsageDescription&lt;/key&gt; &lt;string&gt;亲啊，打开麦克风可以吗？&lt;/string&gt; &lt;key&gt;NSPhotoLibraryUsageDescription&lt;/key&gt; &lt;string&gt;亲啊，打开相册可以吗？&lt;/string&gt; 若没有apple会发此邮箱:123This app attempts to access privacy-sensitive data without a usage description. The app&apos;s Info.plist must contain an NSPhotoLibraryUsageDescription key with a string value explaining to the user how the app uses this data.This app attempts to access privacy-sensitive data without a usage description. The app&apos;s Info.plist must contain an NSCameraUsageDescription key with a string value explaining to the user how the app uses this data. 报错:12- ERROR ITMS-90474: &quot;Invalid Bundle. iPad Multitasking support requires these orientations: &apos;UIInterfaceOrientationPortrait,UIInterfaceOrientationPortraitUpsideDown,UIInterfaceOrientationLandscapeLeft,UIInterfaceOrientationLandscapeRight&apos;. Found &apos;UIInterfaceOrientationPortrait&apos; in bundle &apos;xxxx&apos;.&quot; - ERROR ITMS-90475: &quot;Invalid Bundle. iPad Multitasking support requires launch story board in bundle &apos;xxxx’.&quot; 解决方案:打开项目属性，选择“General”选项，勾选红框标注的“Requires full screen” 报错:1ERROR ITMS-90032:“Invalid Image Path - No image found at the path referenced under key &apos;CFBundleIcons&apos;:AppIcon40x40” 解决方案:图片的问题 缺少对应的图片尺寸 需要在图片资源文件的 appicon中添加]]></content>
      <categories>
        <category>发布问题</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义View 跳转不同界面方法]]></title>
    <url>%2F2016%2F07%2F02%2F%E8%87%AA%E5%AE%9A%E4%B9%89View%20%E8%B7%B3%E8%BD%AC%E4%B8%8D%E5%90%8C%E7%95%8C%E9%9D%A2%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[自定义View 跳转不同界面方法有时候，我们在自定义UIView 的时候 ， 很有可能 会在这个View 进行页面跳转，但是， 你会发现， 那些 push 和 pop 方法 都没什么用 ，那是因为 当一个子view需要接收点击事件，而父view也需要接收点击事件 当然，你可能会说直接调用mysubview.superView即可，这样做也确实是可以做到，但有时子view是不一定知道有这个特定的父view的存在的，如动态添加子view。 所以这里就用到了事件处理与传递。 简单介绍一下 ios当中常用的事件? 123- 触摸事件- 加速计事件- 远程控制事件 什么是响应者对象? 123继承了UIResponds的对象我们称它为响应者对象UIApplication、UIViewController、UIView都继承自UIResponder因此它们都是响应者对象，都能够接收并处理事件 事件是怎么样产生与传递的? 1234567当发生一个触摸事件后,系统会将该事件加入到一个由UIApplication管理的事件队列中.UIApplication会从事件队列中取出最前面的事件，交给主窗口.主窗口会在视图层次结构中找到一个最合适的视图来处理触摸事件触摸事件的传递是从父控件传递到子控件的.如果一个父控件不能接收事件,那么它里面的了子控件也不能够接收事件.``` - 一个控件什么情况下不能够接收事件? 不接收用户交互时不能够处理事件 userInteractionEnabled = NO 当一个控件隐藏的时候不能够接收事件 Hidden = YES的时候 当一个控件为透明白时候也不能够接收事件 alpha &lt;=0.01 123##### 注意:UIImageView的userInteractionEnabled默认就是NO，因此UIImageView以及它的子控件默认是不能接收触摸事件的 - 如何寻找最合适的View? 先判断自己是否能够接收触摸事件,如果能再继续往下判断, 再判断触摸的当前点在不在自己的身上. 如果在自己身上,UIWindow会从后往前（后创建的子控件开始）遍历子控件,遍历出每一个子控件后,重复前面的两个步骤. 如果没有符合条件的子控件,那么它自己就是最适合的View.123456789101112131415161718192021222324 回到主题上来，下面要做的也就是，让子view接收这些事件后，同时把这些事件继续向上传，会一直传到UIApplication为止。而在传的过程中，如果子view接收了这些事件，那么事件会自然终止，我们现在可以做的是同时让子view接收事件，而且还让事件不终止，并继续向上传。步骤应该是：```objc//定义一个全局变量 UIViewController *superVC;//然后执行这个方法- (UIViewController *)viewController:(UIView *)view&#123; UIResponder *responder = view; while ((responder = [responder nextResponder])) if ([responder isKindOfClass: [UIViewController class]])&#123; return (UIViewController *)responder; &#125; return nil;&#125;//最后，在你跳转页面的方法中superVC = [self viewController:self]; [superVC.navigationController pushViewController:（UIViewController） animated:YES]; 这样就可以跳转页面了.]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tableView的性能优化]]></title>
    <url>%2F2016%2F06%2F02%2FtableView%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[tableView性能优化tableview的优化一直是一个很考验基本功的活儿，之前做项目的适合被这个问题困扰了很久，通过性能工具、查阅文档解决，整理思路和解决方案如下： tableview优化最主要：复用cell，header，footer实例；使用约束布局cell子控件时不多次添加约束；图片不过大，尽量不使用透明视图；避免阻塞主线程；计算高度方法不做大量逻辑处理。 cell是否使用了复用机制而不是每一次都创建新的cell。 如果每次都创建新的cell，在滑动的时候会表现为：刚开始的时候很顺畅，但是会越来越卡，内存跟着一直升高，停止滑动的时候也不会降下来。使用缓存机制创建的cell，开始滑动的时候内存会开始上升，等创建了一个屏幕再加半屏的cell之后，内存趋于平稳。 cell是否添加了大量的子控件，或者对layer做了过多的操作。 如果添加了大量的子控件，使用drawRect方法添加子控件，平衡GPU与CPU的负担。同时还需要注意尽量使用不透明视图和不重叠的渐变，否则会加大GPU的负担，造成性能不佳。 高度计算方法时不做复杂的计算，尽量只使用加减乘除。 自适应高度的cell实现方式有很多种，比如， 1.使用iOS7以上系统的 1func tableView(tableView: UITableView, estimatedHeightForRowAtIndexPath indexPath: NSIndexPath) -&gt; CGFloat 这个方法中，可以先给一个估计的高度，系统会从你给定的高度再去计算实际高度。但是在使用过程中会出现cell突然变高变得低的情况，不适用于高度变化太大的cell。 2.如果使用约束布局创建的cell子控件，子控件之间都建立了相互约束，最上面的子控件与cell顶部建立约束，最下面的子控件与cell底部建立了约束，相当于子控件把cell撑开了。 约束简图: 这时在高度计算方法中，走一遍cell的loaddata方法后可以通过 1func systemLayoutSizeFittingSize(targetSize: CGSize) -&gt; CGSize 取得cell的size，进而得到cell高度。通过这个方法获取的cell高度是十分精确的，只要创建好子控件的约束就能获得cell的size。比较不好的是只是这种方法会重走一遍cell的loaddata方法。除此之外在调用cell的loaddata之前需要得到cell的实例，实例创建的方式应该与cellForRow方法一样，优先从缓存池中取得。这个方案可能会创建多个cell。如果能在内存汇总保存一份cell的实例就能解决这个问题了！我讲讲我实现的思路：首先先注册cell,当缓存池中没有cell时系统会自动创建，有的话会直接取缓存中的cell返回给你。 123override func viewDidLodad() &#123; tableView.registerClass(CardCell.self, forCellReuseIdentifier: ID)&#125; 用lazy创建一个cell实例，由于lazy 关键字，cell的创建只会执行一次 12345lazy var cell:CardCell = &#123; //已经注册过cell，当缓存池中没有cell时系统会自动创建，有的话会直接取缓存中的cell返回 let v = self.myTableView?.dequeueReusableCellWithIdentifier(self.ID) as! CardCell return v &#125;() 通过懒加载的方式，只创建一次cell的实例，避免内存浪费。接下来要做的步骤就是之前讲的，调用cell的loadData方法，计算高度 12345func tableView(tableView: UITableView, heightForRowAtIndexPath indexPath: NSIndexPath) -&gt; CGFloat &#123; self.imageCell.loadData(d) let height:CGFloat = self.cell.contentView.systemLayoutSizeFittingSize(UILayoutFittingCompressedSize).heightreturn height&#125; 之前查资料的时候还有用空间换取时间的方案：1）在请求网络数据成功后就计算好高度并通过字典或者数组保存高度值，在高度方法中直接根据数组下标或者key值取得高度并返回。 2）还有建立一个frameModel的方法，与1中相似，只是获得网络数据后保存到frameModel中，在frameModel中定义一个类方法，通过获得的model值计算高度后返回。避免快速滑动情况下开过多线程。cell中的图片开线程异步加载，相信每个人都会想到。线程开过多了会造成资源浪费，内存开销过大。图片过多时可以不要一滚动就走cellForRow方法，可以在scrollview的代理方法中做限制，当滚动开始减速的时候才加载显示在当前屏幕上的cell（通过tableview的dragging和declearating两个状态也能判断） 123456func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell &#123; var canLoad:Bool = !tableView.dragging &amp;&amp; !tableView.declearating if canLoad &#123; //开始loaddata，异步加载图片 &#125;&#125; 图片处理 1）后台下载图片后再回主线程刷新UI，避免阻塞主线程。2）图片过大回造成GPU负担过大，可以在图片下载后压缩尺寸后显示3）避免对layer做过多的操作，尽量设置图片为不透明 补充： 简单的设置cornerRadius是不会影响性能的，但是设置了maskToBounds，会导致离屏渲染，应减少设置图层 maskToBounds = YES ，； 使用懒加载图片的方式避免重复下载图片，浪费资源。图片下载后并做压缩处理后将其保存到缓存中，下次加载此图片之前先从缓存中取，如果取不到该图片就在后台下载保存。 使用Core Graphics实现圆角等功能。 重写drawRect方法会离屏渲染，导致内存急剧上升，即使在这个方法里面不写一句代码，也会让内存升高。]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据安全]]></title>
    <url>%2F2016%2F04%2F05%2F%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[1.Base641.Base64简单说明描述：Base64可以成为密码学的基石，非常重要。 特点：可以将任意的二进制数据进行Base64编码 结果：所有的数据都能被编码为并只用65个字符就能表示的文本文件。 65字符：A~Z a~z 0~9 + / = 对文件进行base64编码后文件数据的变化：编码后的数据~=编码前数据的4/3，会大1/3左右。 2.命令行进行Base64编码和解码编码：base64 123.png -o 123.txt 解码：base64 123.txt -o test.png -D 3.Base64编码原理1)将所有字符转化为ASCII码； 2)将ASCII码转化为8位二进制； 3)将二进制3个归成一组(不足3个在后边补0)共24位，再拆分成4组，每组6位； 4)统一在6位二进制前补两个0凑足8位； 5)将补0后的二进制转为十进制； 6)从Base64编码表获取十进制对应的Base64编码； 处理过程说明： a.转换的时候，将三个byte的数据，先后放入一个24bit的缓冲区中，先来的byte占高位。 b.数据不足3byte的话，于缓冲区中剩下的bit用0补足。然后，每次取出6个bit，按照其值选择查表选择对应的字符作为编码后的输出。 c.不断进行，直到全部输入数据转换完成。 d.如果最后剩下两个输入数据，在编码结果后加1个“=”； e.如果最后剩下一个输入数据，编码结果后加2个“=”； f.如果没有剩下任何数据，就什么都不要加，这样才可以保证资料还原的正确性。 4.实现a.说明： 1）从iOS7.0 开始，苹果就提供了base64的编码和解码支持 2)如果是老项目，则还能看到base64编码和解码的第三方框架，如果当前不再支持iOS7.0以下版本，则建议替换。 b.相关代码： //给定一个字符串，对该字符串进行Base64编码，然后返回编码后的结果 -(NSString *)base64EncodeString:(NSString *)string { //1.先把字符串转换为二进制数据 NSData *data = [string dataUsingEncoding:NSUTF8StringEncoding]; //2.对二进制数据进行base64编码，返回编码后的字符串 return [data base64EncodedStringWithOptions:0]; } //对base64编码后的字符串进行解码 -(NSString *)base64DecodeString:(NSString *)string { //1.将base64编码后的字符串『解码』为二进制数据 NSData *data = [[NSData alloc]initWithBase64EncodedString:string options:0]; //2.把二进制数据转换为字符串返回 return [[NSString alloc]initWithData:data encoding:NSUTF8StringEncoding]; } c.终端测试命令 $ echo -n A | base64 $ echo -n QQ== |base64 -D 2.常见的加密算法和其它 base64 编码格式 密码学演化 “秘密本”–&gt;RSA 常见的加密算法 消息摘要（单向散列函数） 对称加密 非对称加密 证书等 3.单向散列函数1.单向散列函数的特点：①加密后密文的长度是定长的 ②如果明文不一样，那么散列后的结果一定不一样 ③如果明文一样，那么加密后的密文一定一样（对相同数据加密，加密后的密文一样） ④所有的加密算法是公开的 ⑤不可以逆推反算 2.经典加密算法1）MD5加密 2）SHA1 3）SHA512 3.MD5加密算法简单说明1）对字符串进行MD5加密可以得到一个32个字符的密文 2）加密之后不能根据密文逆推出明文 3）MD5已经被破解（暴力破解|碰撞检测） 4.MD5加密进阶1）先加盐，然后再进行MD5 2）先乱序，再进行MD5加密 3）乱序|加盐，多次MD5加密等 4）使用消息认证机制，即HMAC-MD5-先对密钥进行加密，加密之后进行两次MD5散列 5）加密命令行 MD5加密-字符串 $ echo -n &quot;520it&quot; |md5 MD5加密-文件1 $ md5 abc.png SHA1加密： $ echo -n &quot;520it&quot; |openssl sha -sha1 SHA256 $ echo -n &quot;520it&quot; |openssl sha -sha256 SHA512 $ echo -n &quot;520it&quot; |openssl sha -sha512 hmacMD5加密 $ echo -n &quot;520it&quot; |openssl dgst -md5 -hmac &quot;123&quot; 5.散列函数应用领域1）搜索 多个关键字，先对每个关键字进行散列，然后多个关键字进行或运算，如果值一致则搜索结果一致 2）版权 对文件进行散列判断该文件是否是正版或原版的 3）文件完整性验证 对整个文件进行散列，比较散列值判断文件是否完整或被篡改 6.消息认证机制（HMAC）简单说明1）原理 ①消息的发送者和接收者有一个共享密钥 ②发送者使用共享密钥对消息加密计算得到MAC值（消息认证码） ③消息接收者使用共享密钥对消息加密计算得到MAC值 ④比较两个MAC值是否一致 2）使用 ①客户端需要在发送的时候把（消息）+（消息·HMAC）一起发送给服务器 ②服务器接收到数据后，对拿到的消息用共享的KEY进行HMAC，比较是否一致，如果一致则信任 4.对称加密1.对称加密的特点1）加密/解密使用相同的密钥 2）加密和解密的过程是可逆的（明文-》明文-》明文） 2.经典算法1）DES 数据加密标准 2）3DES 使用3个密钥，对消息进行（密钥1·加密）+（密钥2·解密）+（密钥3·加密） 3）AES 高级加密标准 3.分组密码简单说明密码算法可以分为分组密码和流密码两种。 分组密码：每次只能处理特定长度的一zu数据的一类密码算法。一个分组的比特数量就称之为分组长度。 ex:DES和3DES的分组长度都是64比特。即每次只能加密64比特的明文，并生成64比特的密文。AES的分组长度有128比特、192比特和256比特可以选择。 流密码：对数据流进行连续处理的一类算法。流密码中一般以1比特、8比特或者是32比特等作为单位俩进行加密和解密。 4.ECB分组模式ECB模式的全称为Electronic CodeBook模式。又成为电子密码本模式。 特点： 1）使用ECB模式加密的时候，相同的明文分组会被转换为相同的密文分组。 2）类似于一个巨大的明文分组-》密文分组的对照表。 终端测试命令： 加密 $ openssl enc -des-ecb -K 616263 -nosalt -in 123.txt -out 123.bin 解密 $ openssl enc -des-ecb -K 616263 -nosalt -in 123.bin -out 1231.txt -d 5.CBC分组模式CBC模式全称为Cipher Block Chainning模式（密文分组链接模式|电子密码链条） 特点：在CBC模式中，首先将明文分组与前一个密文分组进行XOR运算，然后再进行加密。 终端命令： 加密 $ openssl enc -des-cbc -K 616263 -iv 0102030405060708 -nosalt -in a.txt -out a.bin 解密 $ openssl enc -des-cbc -K 616263 -iv 0102030405060708 -nosalt -in a.bin -out a1.txt -d 5.非对称加密1.非对称加密的特点1）使用公钥加密，使用私钥解密 2）公钥是公开的，私钥保密 3）加密处理安全，但是性能极差 2.经典算法—RSA1）RSA 原理 （1）求N，准备两个质数p和q,N = p x q （2）求L,L是p-1和q-1的最小公倍数。L = lcm（p-1,q-1） （3）求E，E和L的最大公约数为1（E和L互质） （4）求D，E x D mode L = 1 2）RSA加密小实践 （1）p = 17,q = 19 =&gt;N = 323 （2）lcm（p-1,q-1）=&gt;lcm（16，18）=&gt;L= 144 （3）gcd（E,L）=1 =&gt;E=5 （4）E乘以几可以mode L =1? D=29可以满足 （5）得到公钥为：E=5,N=323 （6）得到私钥为：D=29,N=323 （7）加密 明文的E次方 mod N = 123的5次方 mod 323 = 225（密文） （8）解密 密文的D次方 mod N = 225的29次方 mod 323 = 123（明文） ---------------- 3）openssl生成密钥命令 生成强度是 512 的 RSA 私钥：$ openssl genrsa -out private.pem 512 以明文输出私钥内容：$ openssl rsa -in private.pem -text -out private.txt 校验私钥文件：$ openssl rsa -in private.pem -check 从私钥中提取公钥：$ openssl rsa -in private.pem -out public.pem -outform PEM -pubout 以明文输出公钥内容：$ openssl rsa -in public.pem -out public.txt -pubin -pubout -text 使用公钥加密小文件：$ openssl rsautl -encrypt -pubin -inkey public.pem -in msg.txt -out msg.bin 使用私钥解密小文件：$ openssl rsautl -decrypt -inkey private.pem -in msg.bin -out a.txt 将私钥转换成 DER 格式：$ openssl rsa -in private.pem -out private.der -outform der 将公钥转换成 DER 格式：$ openssl rsa -in public.pem -out public.der -pubin -outform der ----------------- 6.数字签名1.数字签名的应用场景答：需要严格验证发送方身份信息情况 2.数字签名原理1）客户端处理 ①对&quot;消息&quot;进行 HASH 得到 &quot;消息摘要&quot; ②发送方使用自己的私钥对&quot;消息摘要&quot; 加密(数字签名) ③把数字签名附着在&quot;报文&quot;的末尾一起发送给接收方 2）服务端处理 ①对&quot;消息&quot; HASH 得到 &quot;报文摘要&quot; ②使用公钥对&quot;数字签名&quot; 解密 ③对结果进行匹配 7.数字证书1.简单说明证书和驾照很相似，里面记有姓名、组织、地址等个人信息，以及属于此人的公钥，并有认证机构施加数字签名,只要看到公钥证书，我们就可以知道认证机构认证该公钥的确属于此人 2.数字证书的内容1）公钥 2）认证机构的数字签名 3.证书的生成步骤1）生成私钥 openssl genrsa -out private.pem 1024 2）创建证书请求 openssl req -new -key private.pem -out rsacert.csr 3）生成证书并签名，有效期10年 openssl x509 -req -days 3650 -in rsacert.csr -signkey private.pem -out rsacert.crt 4）将 PEM 格式文件转换成 DER 格式 openssl x509 -outform der -in rsacert.crt -out rsacert.der 5）导出P12文件 openssl pkcs12 -export -out p.p12 -inkey private.pem -in rsacert.crt 4.iOS开发中的注意点1）在iOS开发中，不能直接使用 PEM 格式的证书，因为其内部进行了Base64编码，应该使用的是DER的证书，是二进制格式的 2）OpenSSL默认生成的都是PEM格式的证书]]></content>
      <categories>
        <category>数据安全</category>
      </categories>
      <tags>
        <tag>数据加密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[siwft笔记3]]></title>
    <url>%2F2016%2F01%2F27%2Fsiwft%E7%AC%94%E8%AE%B03%2F</url>
    <content type="text"><![CDATA[一.三大特性 封装 继承 重写父类方法 需要加上 override 多态 必须要有继承 必须要有重写 必须是父类指针指向子类对象 (重载) 参数类型不同 参数个数不同 二.自动引用计数 当有一个强引用指向某个对象时,该对象的引用计数会自动 + 1 当强引用消失时,引用计数会自动 - 1 当引用计数为0时,该对象会被销毁 循环引用 的解决1.weak 和OC中的 __weak一样 是弱引用 当指向的对象销毁时,会自动指向nil 2.unowned 和OC中的 __unsefe_unretained 当对象销毁时依然指向原来的位置(容易引起野指针) 三.可选链 如果可选的目标有值,就调用成功 如果没有值,则调用返回空nil 12 // OC对象结构体的成员属性不能直接赋值 titleLabel?.frame.origin.x = 0 四.协议 protocol 定义协议和遵守协议 1234567891011121314151617// 1.定义协议protocol SportProtocol &#123; func playBasketball() func playFootball()&#125;// 2.遵守协议// 注意:默认情况下在swift中所有的协议方法都是必须实现的,如果不实现,则编译器会报错class Person : SportProtocol &#123; var name : String? var age : Int = 0 // 实现协议中的方法 func playBasketball() &#123; print(&quot;人在打篮球&quot;) &#125; func playFootball() &#123; print(&quot;人在踢足球&quot;) &#125;&#125; 协议之间的继承 1234567protocol CrazySportProtocol &#123; func jumping()&#125;protocol SportProtocol : CrazySportProtocol &#123; func playBasketball() func playFootball()&#125; 协议中方法的可选 需加 @objc 和 optional 关键字123456789101112131415// 1.定义协议@objcprotocol SportProtocol &#123; func playBasketball() optional func playFootball()&#125;// 2.遵守协议class Person : SportProtocol &#123; var name : String? var age : Int = 0 // 实现协议中的方法 @objc func playBasketball() &#123; print(&quot;人在打篮球&quot;) &#125;&#125; 代理协议 123456789101112131415161718191.定义协议属性 用 weak 且协议后面需 : class 才不会报错protocol BuyTicketProtocol : class &#123; func buyTicket()&#125;class Person &#123; // 1.定义协议属性 weak var delegate : BuyTicketProtocol func goToHeFei()&#123; delegate?.buyTicketing() print(&quot;去北京&quot;) &#125;&#125;class Huangniu: BuyTicketDelegate &#123; func buyTicketing() &#123; print(&quot;买票&quot;) &#125;&#125;//代理对象//设置代理时 没有self 需要先 let 创建代理对象 然后再 设置代理 = 代理对象let h = Huangniu()let p = Person()p.delegate = hp.goToHeFei() 五.闭包 (类似OC中的Block) block的写法: 12345 类型: 返回值(^block的名称)(block的参数) 值: ^(参数列表) &#123; // 执行的代码 &#125;; 闭包的写法: 1234567 类型:(形参列表)-&gt;(返回值) 技巧:初学者定义闭包类型,直接写()-&gt;().再填充参数和返回值 值: &#123; (形参) -&gt; 返回值类型 in // 执行代码 &#125; 闭包的循环引用 1234567891011121314/* 需要用到self的地方: 1.如果某一个方法中,有局部变量和成员变量产生歧义,可以使用self进行区分 2.如果在闭包中使用到当前对象的方法或者属性,都需要加self */// 解决方案一: weak var weakself : ViewController? = self httpTool?.loadData(&#123; (jsonData) -&gt; () in weakself?.view.backgroundColor = UIColor.redColor() &#125;)// 解决方案二:(推荐) httpTool?.loadData(&#123;[weak self] (jsonData) -&gt; () in self?.view.backgroundColor = UIColor.redColor() &#125;) 六.懒加载 格式 1lazy var 变量: 类型 = &#123; 创建变量代码 &#125;() 懒加载的使用 12345678910// 懒加载的本质是,在第一次使用的时候执行闭包,将闭包的返回值赋值给属性// lazy的作用是只会赋值一次 lazy var array : [String] = &#123; return [&quot;why&quot;, &quot;lmj&quot;, &quot;lnj&quot;] &#125;() lazy var btn : UIButton = &#123; let tempBtn = UIButton() tempBtn.setTitle(&quot;按钮&quot;, forState: .Normal) return tempBtn &#125;() 七.常见注释 单行注释 1// 注释内容 多行注释 123/* (与OC不同 可以多行嵌套多行注释) */ 文档注释 1// 注释内容 分组注释 1// MARK:- 八.访问权限 Swift 中的访问控制模型基于模块和源文件这两个概念 private : 修饰源文件,在当前源文件中可以访问 internal : 内部的,修饰整个项目,在整个项目中都可以进行访问,并且默认修饰的就是internal public : 修饰整个项目,可以跨框架使用(在class 和 func前面加) 九.处理异常 (三种方式)123456789// 3.异常的处理三种方式// 3.1.try方式,需要手动处理异常do &#123; let result = try readFileContent(&quot;abc&quot;)&#125; catch &#123; print(error)&#125;// 3.2.try?方式,不处理异常,如果出现了异常,则返回一个nil.没有异常,则返回对应的值// 最终返回结果为一个可选类型let result = try? readFileContent(&quot;abc&quot;)// 3.3.try!方法,告诉系统该方法没有异常.// 注意:如果出现了异常,则程序会崩溃 let result = try! readFileContent(&quot;abc&quot;) 12345678910111213示例// 1.定义异常enum FileReadError : ErrorType &#123; case FileISNull case FileNotFound&#125;// 2.改进方法,让方法抛出异常func readFileContent(filePath : String) throws -&gt; String &#123; // 1.filePath为&quot;&quot; if filePath == &quot;&quot; &#123; throw FileReadError.FileISNull &#125; // 2.filepath有值,但是没有对应的文件 if filePath != &quot;/User/Desktop/123.plist&quot; &#123; throw FileReadError.FileISNull &#125; // 3.取出其中的内容 return &quot;123&quot;&#125; 十.桥接 OC调用swift 123451.直接写入一个头文件: 项目名字-Swift.h #import &quot;项目名字-Swift.h&quot;2.在swift中 添加public关键字 在class和func前面 (还是以OC格式书写) swift调用OC 1231.建立桥接文件 Bridge.h 里面放 .h头文件2.在项目中Build Settings 配置文件 搜索bird 然后将Bridge.h路径存入(类似PCH文件)]]></content>
      <categories>
        <category>swift笔记</category>
      </categories>
      <tags>
        <tag>swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift笔记2]]></title>
    <url>%2F2016%2F01%2F26%2Fswift%E7%AC%94%E8%AE%B02%2F</url>
    <content type="text"><![CDATA[字符串的介绍 字符串在任何的开发中使用都是非常频繁的 OC和Swift中字符串的区别 在OC中字符串类型时NSString,在Swift中字符串类型是String OC中字符串@””,Swift中字符串”” 使用 String 的原因 String 是一个结构体，性能更高 NSString 是一个 OC 对象，性能略差 String 支持直接遍历 Swift 提供了 String 和 NSString 之间的无缝转换 字符的定义 定义不可变字符串let str = &quot;hello Objective-C&quot; 定义可变字符串var str = &quot;hello Swift&quot; 字符串的使用获取字符串的长度 获取字符集合,再获取集合的count属性let count = str.characters.count 遍历字符串 1234var str = &quot;Hello, Swift&quot;for c in str.characters &#123; print(c)&#125; 字符串拼接 两个字符串的拼接 123let str1 = &quot;Hello&quot;let str2 = &quot;World&quot;let str3 = str1 + str2 字符串和其他数据类型的拼接 1234567let name = &quot;why&quot; let age = 18 let info = &quot;my name is \(name), age is \(age)&quot; ``` - 字符串的格式化 - 比如时间:03:04 let min = 3 let second = 4 let time = String(format: “%02d:%02d”, arguments: [min, second])12345678###字符串的截取- Swift中提供了特殊的截取方式 - 该方式非常麻烦 - Index创建较为麻烦- 简单的方式是将String转成NSString来使用 - 在标识符后加:as NSString即可 let myStr = “www.520it.com”var subStr = (myStr as NSString).substringFromIndex(4)subStr = (myStr as NSString).substringToIndex(3)subStr = (myStr as NSString).substringWithRange(NSRange(location: 4, length: 5))1- swift截取方式 // 1.定义字符串let str = “www.520it.com” // 2.截取开始位置let fromIndex = str.startIndex.advancedBy(3)let header = str.substringFromIndex(fromIndex) // 3.截取结束位置let toIndex = str.endIndex.advancedBy(-3)let footer = str.substringToIndex(toIndex) // 4.截取中间的字符串let range = Range(start: str.startIndex.advancedBy(4), end: str.endIndex.advancedBy(-4))let middle = str.substringWithRange(range)```]]></content>
      <categories>
        <category>swift笔记</category>
      </categories>
      <tags>
        <tag>swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[swift笔记1]]></title>
    <url>%2F2016%2F01%2F25%2Fswift%2F</url>
    <content type="text"><![CDATA[Swift最基本的语法变化 导入框架 import UIKit 定义标识符时，必须声明该标识符是变量还是常量声明标识符的格式:变量/常量关键字 名称 : 数据类型 语句结束时不需要加 ;如果同一行有多个语句,则依然需要加但是不建议一行多条语句 Swift中的打印语句: print(“打印的内容”) 什么是常量和变量 在Swift中规定:在定义一个标识符时必须明确说明该标识符是一个常量还是变量1.使用let来定义常量,定义之后不可以修改2.使用var来定义变量,定义之后可以修改 注意:在真实使用过程中,建议先定义常量,如果需要修改再修改为变量(更加安全)是指向的对象不可以再进行修改.但是可以通过指针获得对象后,修改对象内部的属性 类型推导Swift是强类型的语言Swift中任何一个标识符都有明确的类型 注意:1.如果定义一个标识符时有直接进行赋值,那么标识符后面的类型可以省略.2.因为Swift有类型推导,会自动根据后面的赋值来决定前面的标识符的数据类型 可以通过option+鼠标左键 来查看变量的数据类型 Swift中基本运算1.Swift中在进行基本运算时必须保证类型一致,否则会出错相同类型之间才可以进行运算因为Swift中没有隐式转换 2.数据类型的转化Int类型转成Double类型:Double(标识符)Double类型转成Int类型:Int(标识符) 12345678let a = 10let b = 3.14// 错误写法 //let c = a + b //let c = a * b// 正确写法let c = Double(a) + blet d = a + Int(b) if分支语句和OC中if语句有一定的区别判断句可以不加()在Swift的判断句中必须有明确的真假不再有非0即真必须有明确的Bool值Bool有两个取值:false/true guard的使用guard语句必须带有else语句，它的语法如下：当条件表达式为true时候跳过else语句中的内容，执行语句组内容条件表达式为false时候执行else语句中的内容，跳转语句一般是return、break、continue和throw 123guard 条件表达式 else &#123; // 条换语句 break&#125;语句组 switch分支基本用法和OC用法一致不同之处:switch后可以不跟()case后可以不跟break(默认会有break) 简单使用补充:1.一个case判断中,可以判断多个值多个值以, 隔开 如果希望出现之前的case穿透,则可以使用关键字fallthrough 2.什么是区间?通常我们指的是数字区间:0~10,100~200 3.swift中的区间常见有两种半开半闭区间:0..&lt;10 表示:0~9,不包括10闭区间:0…10 表示:0~10 123456789101112let score = 88switch score &#123; case 0..&lt;60: print(&quot;不及格&quot;) case 60..&lt;80: print(&quot;几个&quot;) case 80..&lt;90: print(&quot;良好&quot;) case 90..&lt;100: print(&quot;优秀&quot;) default: print(&quot;满分&quot;)&#125; 循环的介绍 在开发中经常会需要循环 常见的循环有:for/while/do while. 这里我们只介绍for/while,因为for/while最常见 for循环的写法 最常规写法 1234// 传统写法for var i = 0; i &lt; 10; i++ &#123; print(i)&#125; 区间for循环 12345678//半开半闭区间for i in 0..&lt;10 &#123; print(i)&#125;//闭区间for i in 0...10 &#123; print(i)&#125; 特殊写法如果在for循环中不需要用到下标i 123for _ in 0..&lt;10 &#123; print(&quot;hello&quot;)&#125; while和do while循环 while循环 while的判断句必须有正确的真假,没有非0即真 while后面的()可以省略 1234var a = 0while a &lt; 10 &#123; a++&#125; do while循环使用 repeat关键字来代替了do 12345let b = 0repeat &#123; print(b) b++&#125; while b &lt; 20]]></content>
      <categories>
        <category>swift笔记</category>
      </categories>
      <tags>
        <tag>swift</tag>
      </tags>
  </entry>
</search>
